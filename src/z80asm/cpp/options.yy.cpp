// cpp/options.yy.cpp generated by reflex 2.0.1 from cpp/options.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_dotall              true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "cpp/options.yy.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               OptionsLexer
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "cpp/options.yy.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


	// silence warnings from RE-flex
	#ifdef _MSC_VER
	#pragma warning(disable:4102)
	#pragma warning(disable:4800)
	#else
	#ifdef __GNUC__
	//#pragma GCC   diagnostic ignored "-Wignored-qualifiers"
	#else
	#ifdef __clang__
	//#pragma clang diagnostic ignored "-Wignored-qualifiers"
	#endif
	#endif
	#endif

	#include "legacy.h"

	#include "config.h"
	#include "z80asm_manual.h"
	#include "z80asm_usage.h"

	#include <cassert>
	#include <iostream>
	#include <string>
	#include <vector>

	#ifndef Z88DK_VERSION
	#define Z88DK_VERSION "build " __DATE__
	#endif


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class OptionsLexer : public reflex::AbstractLexer<reflex::Matcher> {

	private:
		static const char copyrightmsg[];

		bool verbose;				// true to be verbose
		int cpu;					// TODO: replace with class enum
		bool isTi83Plus;			// true for the TI83Plus
		std::string cpuName;		// used to search libraries
		bool swapIxIy;				// swap IX and IY
		bool optimizeSpeed;			// true to optimize for speed
		std::string envPendingOpts;	// options from environment to parse by the C code
									// TODO: to remove
		std::vector<std::string> defines;	// list of -D defines

	public:
		bool ParseEnv(const std::string& envVariable = "Z80ASM");	// parse options from environment
		bool ParseArgs(int argc, char* argv[]);						// parse options from ARGV

		bool IsVerbose() const { return verbose; }
		const char* GetEnvPendingOpts() const { return envPendingOpts.c_str(); }
		int GetCpu() const { return cpu; }
		const std::string& GetCpuName() const { return cpuName; }
		bool IsTi83Plus() const { return isTi83Plus; }
		bool SwapIxIy() const { return swapIxIy; }
		bool IsOptimizeSpeed() const { return optimizeSpeed; }
		auto cbeginDefines() const { return defines.cbegin(); }
		auto cendDefines() const { return defines.cend(); }

	private:
		void ShowManual() const;

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  OptionsLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// z80asm restart
// Copyright (C) Paulo Custodio, 2011-2020
// License: The Artistic License 2.0, http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int OptionsLexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 75: -v\z|--verbose\z :
{ verbose = true; return true; }

            break;
          case 2: // rule at line 79: -\?\z|-h\z|--help\z :
{ ShowManual(); return true; }

            break;
          case 3: // rule at line 82: -m=?z80\z|--cpu=?z80\z :
{ cpu = CPU_Z80; return true; }

            break;
          case 4: // rule at line 85: -m=?z80n\z|--cpu=?z80n\z :
{ cpu = CPU_Z80N; return true; }

            break;
          case 5: // rule at line 88: -m=?z180\z|--cpu=?z180\z :
{ cpu = CPU_Z180; return true; }

            break;
          case 6: // rule at line 91: -m=?r2k\z|--cpu=?r2k\z :
{ cpu = CPU_R2K; return true; }

            break;
          case 7: // rule at line 94: -m=?r3k\z|--cpu=?r3k\z :
{ cpu = CPU_R3K; return true; }

            break;
          case 8: // rule at line 97: -m=?8080\z|--cpu=?8080\z :
{ cpu = CPU_8080; return true; }

            break;
          case 9: // rule at line 100: -m=?8085\z|--cpu=?8085\z :
{ cpu = CPU_8085; return true; }

            break;
          case 10: // rule at line 103: -m=?gbz80\z|--cpu=?gbz80\z :
{ cpu = CPU_GBZ80; return true; }

            break;
          case 11: // rule at line 106: -m=?ti83\z|--cpu=?ti83\z :
{ cpu = CPU_Z80; isTi83Plus = false; return true; }	// TODO: define __ARCH_TI83__

            break;
          case 12: // rule at line 109: -m=?ti83plus\z|--cpu=?ti83plus\z :
{ cpu = CPU_Z80; isTi83Plus = true; return true; }	// TODO: define __ARCH_TI83PLUS__

            break;
          case 13: // rule at line 112: -IXIY\z|--IXIY\z :
{ swapIxIy = true; return true; }

            break;
          case 14: // rule at line 114: --opt=speed :
{ optimizeSpeed = true; return true; }

            break;
          case 15: // rule at line 116: [\x00-\xff] :
{ return false; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


const char OptionsLexer::copyrightmsg[]{
	"Z80 Module Assembler " Z88DK_VERSION "\n"
		"(c) InterLogic 1993-2009, Paulo Custodio 2011-2020"
};

bool OptionsLexer::ParseEnv(const std::string& envVariable)
{
	using namespace std;

	envPendingOpts.clear();

	const char *opts = getenv(envVariable.c_str());
	if (!opts)
		return true;
	stringstream iss{ string(opts) };
	string arg;

	while (iss >> arg) {
		in(arg);
		if (!lex()) {						// TODO: error handling
			envPendingOpts += arg + " ";	// pass options not parsed to the C code
		}
	}

	return true;
}

bool OptionsLexer::ParseArgs(int argc, char* argv[])
{
	using namespace std;

	// if no arguments, just show usage and exit
	if (argc == 1) {
		cout << copyrightmsg << endl << endl
			<< z80asm_usage;
		exit(EXIT_SUCCESS);
	}

	// parse options
	for (int i = 1; i < argc; ++i) {
		in(argv[i]);
		if (lex())
			argv[i][0] = '\0';		// cancel this argument for next pass
		else {						// TODO: error handling
		}
	}

	switch (cpu) {		// TODO: use a lookup-table
	case CPU_NOT_DEFINED:
		cpu = CPU_Z80;
		// fall through
	case CPU_Z80:
		cpuName = CPU_Z80_NAME;
		defines.push_back(CPU_Z80_DEFINE);
		defines.push_back(CPU_ZILOG_DEFINE);
		break;
	case CPU_Z80N:
		cpuName = CPU_Z80N_NAME;
		defines.push_back(CPU_Z80N_DEFINE);
		defines.push_back(CPU_ZILOG_DEFINE);
		break;
	case CPU_Z180:
		cpuName = CPU_Z180_NAME;
		defines.push_back(CPU_Z180_DEFINE);
		defines.push_back(CPU_ZILOG_DEFINE);
		break;
	case CPU_R2K:
		cpuName = CPU_R2K_NAME;
		defines.push_back(CPU_R2K_DEFINE);
		defines.push_back(CPU_RABBIT_DEFINE);
		break;
	case CPU_R3K:
		cpuName = CPU_R3K_NAME;
		defines.push_back(CPU_R3K_DEFINE);
		defines.push_back(CPU_RABBIT_DEFINE);
		break;
	case CPU_8080:
		cpuName = CPU_8080_NAME;
		defines.push_back(CPU_8080_DEFINE);
		defines.push_back(CPU_INTEL_DEFINE);
		break;
	case CPU_8085:
		cpuName = CPU_8085_NAME;
		defines.push_back(CPU_8085_DEFINE);
		defines.push_back(CPU_INTEL_DEFINE);
		break;
	case CPU_GBZ80:
		cpuName = CPU_GBZ80_NAME;
		defines.push_back(CPU_GBZ80_DEFINE);
		break;
	default:
		assert(0);
	}

	return true;
}

void OptionsLexer::ShowManual() const
{
	using namespace std;
	cout << z80asm_manual;
	exit(EXIT_SUCCESS);
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S2;
  if (0 <= c1) goto S10;
  return m.FSM_HALT(c1);

S2:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (c1 == 'v') goto S12;
  if (c1 == 'm') goto S24;
  if (c1 == 'h') goto S22;
  if (c1 == 'I') goto S31;
  if (c1 == '?') goto S20;
  if (c1 == '-') goto S14;
  return m.FSM_HALT(c1);

S10:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S12:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(1, c1);
  }
  return m.FSM_HALT(c1);

S14:
  c1 = m.FSM_CHAR();
  if (c1 == 'v') goto S35;
  if (c1 == 'o') goto S43;
  if (c1 == 'h') goto S37;
  if (c1 == 'c') goto S39;
  if (c1 == 'I') goto S41;
  return m.FSM_HALT(c1);

S20:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(2, c1);
  }
  return m.FSM_HALT(c1);

S22:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(2, c1);
  }
  return m.FSM_HALT(c1);

S24:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S47;
  if (c1 == 't') goto S57;
  if (c1 == 'r') goto S50;
  if (c1 == 'g') goto S55;
  if (c1 == '=') goto S59;
  if (c1 == '8') goto S53;
  return m.FSM_HALT(c1);

S31:
  c1 = m.FSM_CHAR();
  if (c1 == 'X') goto S65;
  return m.FSM_HALT(c1);

S33:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S35:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S67;
  return m.FSM_HALT(c1);

S37:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S69;
  return m.FSM_HALT(c1);

S39:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S71;
  return m.FSM_HALT(c1);

S41:
  c1 = m.FSM_CHAR();
  if (c1 == 'X') goto S73;
  return m.FSM_HALT(c1);

S43:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S75;
  return m.FSM_HALT(c1);

S45:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S47:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S77;
  if (c1 == '1') goto S79;
  return m.FSM_HALT(c1);

S50:
  c1 = m.FSM_CHAR();
  if (c1 == '3') goto S83;
  if (c1 == '2') goto S81;
  return m.FSM_HALT(c1);

S53:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S85;
  return m.FSM_HALT(c1);

S55:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S87;
  return m.FSM_HALT(c1);

S57:
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S89;
  return m.FSM_HALT(c1);

S59:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S47;
  if (c1 == 't') goto S57;
  if (c1 == 'r') goto S50;
  if (c1 == 'g') goto S55;
  if (c1 == '8') goto S53;
  return m.FSM_HALT(c1);

S65:
  c1 = m.FSM_CHAR();
  if (c1 == 'I') goto S91;
  return m.FSM_HALT(c1);

S67:
  c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S93;
  return m.FSM_HALT(c1);

S69:
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S95;
  return m.FSM_HALT(c1);

S71:
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S97;
  return m.FSM_HALT(c1);

S73:
  c1 = m.FSM_CHAR();
  if (c1 == 'I') goto S104;
  return m.FSM_HALT(c1);

S75:
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S106;
  return m.FSM_HALT(c1);

S77:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S108;
  return m.FSM_HALT(c1);

S79:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S111;
  return m.FSM_HALT(c1);

S81:
  c1 = m.FSM_CHAR();
  if (c1 == 'k') goto S113;
  return m.FSM_HALT(c1);

S83:
  c1 = m.FSM_CHAR();
  if (c1 == 'k') goto S115;
  return m.FSM_HALT(c1);

S85:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S117;
  return m.FSM_HALT(c1);

S87:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S120;
  return m.FSM_HALT(c1);

S89:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S122;
  return m.FSM_HALT(c1);

S91:
  c1 = m.FSM_CHAR();
  if (c1 == 'Y') goto S124;
  return m.FSM_HALT(c1);

S93:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S126;
  return m.FSM_HALT(c1);

S95:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S128;
  return m.FSM_HALT(c1);

S97:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S130;
  if (c1 == 't') goto S140;
  if (c1 == 'r') goto S133;
  if (c1 == 'g') goto S138;
  if (c1 == '=') goto S142;
  if (c1 == '8') goto S136;
  return m.FSM_HALT(c1);

S104:
  c1 = m.FSM_CHAR();
  if (c1 == 'Y') goto S148;
  return m.FSM_HALT(c1);

S106:
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S150;
  return m.FSM_HALT(c1);

S108:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(3, c1);
  }
  if (c1 == 'n') goto S154;
  return m.FSM_HALT(c1);

S111:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S156;
  return m.FSM_HALT(c1);

S113:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(6, c1);
  }
  return m.FSM_HALT(c1);

S115:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(7, c1);
  }
  return m.FSM_HALT(c1);

S117:
  c1 = m.FSM_CHAR();
  if (c1 == '5') goto S164;
  if (c1 == '0') goto S162;
  return m.FSM_HALT(c1);

S120:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S166;
  return m.FSM_HALT(c1);

S122:
  c1 = m.FSM_CHAR();
  if (c1 == '3') goto S168;
  return m.FSM_HALT(c1);

S124:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(13, c1);
  }
  return m.FSM_HALT(c1);

S126:
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S173;
  return m.FSM_HALT(c1);

S128:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(2, c1);
  }
  return m.FSM_HALT(c1);

S130:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S175;
  if (c1 == '1') goto S177;
  return m.FSM_HALT(c1);

S133:
  c1 = m.FSM_CHAR();
  if (c1 == '3') goto S181;
  if (c1 == '2') goto S179;
  return m.FSM_HALT(c1);

S136:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S183;
  return m.FSM_HALT(c1);

S138:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S185;
  return m.FSM_HALT(c1);

S140:
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S187;
  return m.FSM_HALT(c1);

S142:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S130;
  if (c1 == 't') goto S140;
  if (c1 == 'r') goto S133;
  if (c1 == 'g') goto S138;
  if (c1 == '8') goto S136;
  return m.FSM_HALT(c1);

S148:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(13, c1);
  }
  return m.FSM_HALT(c1);

S150:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S189;
  return m.FSM_HALT(c1);

S152:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S154:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(4, c1);
  }
  return m.FSM_HALT(c1);

S156:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(5, c1);
  }
  return m.FSM_HALT(c1);

S158:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S160:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S162:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(8, c1);
  }
  return m.FSM_HALT(c1);

S164:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(9, c1);
  }
  return m.FSM_HALT(c1);

S166:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S199;
  return m.FSM_HALT(c1);

S168:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(11, c1);
  }
  if (c1 == 'p') goto S203;
  return m.FSM_HALT(c1);

S171:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S173:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S205;
  return m.FSM_HALT(c1);

S175:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S207;
  return m.FSM_HALT(c1);

S177:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S210;
  return m.FSM_HALT(c1);

S179:
  c1 = m.FSM_CHAR();
  if (c1 == 'k') goto S212;
  return m.FSM_HALT(c1);

S181:
  c1 = m.FSM_CHAR();
  if (c1 == 'k') goto S214;
  return m.FSM_HALT(c1);

S183:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S216;
  return m.FSM_HALT(c1);

S185:
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S219;
  return m.FSM_HALT(c1);

S187:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S221;
  return m.FSM_HALT(c1);

S189:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S223;
  return m.FSM_HALT(c1);

S191:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S193:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S195:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S197:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S199:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(10, c1);
  }
  return m.FSM_HALT(c1);

S201:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S203:
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S227;
  return m.FSM_HALT(c1);

S205:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S229;
  return m.FSM_HALT(c1);

S207:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(3, c1);
  }
  if (c1 == 'n') goto S231;
  return m.FSM_HALT(c1);

S210:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S233;
  return m.FSM_HALT(c1);

S212:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(6, c1);
  }
  return m.FSM_HALT(c1);

S214:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(7, c1);
  }
  return m.FSM_HALT(c1);

S216:
  c1 = m.FSM_CHAR();
  if (c1 == '5') goto S237;
  if (c1 == '0') goto S235;
  return m.FSM_HALT(c1);

S219:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S239;
  return m.FSM_HALT(c1);

S221:
  c1 = m.FSM_CHAR();
  if (c1 == '3') goto S241;
  return m.FSM_HALT(c1);

S223:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S244;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S227:
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S246;
  return m.FSM_HALT(c1);

S229:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(1, c1);
  }
  return m.FSM_HALT(c1);

S231:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(4, c1);
  }
  return m.FSM_HALT(c1);

S233:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(5, c1);
  }
  return m.FSM_HALT(c1);

S235:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(8, c1);
  }
  return m.FSM_HALT(c1);

S237:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(9, c1);
  }
  return m.FSM_HALT(c1);

S239:
  c1 = m.FSM_CHAR();
  if (c1 == '0') goto S248;
  return m.FSM_HALT(c1);

S241:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(11, c1);
  }
  if (c1 == 'p') goto S250;
  return m.FSM_HALT(c1);

S244:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S252;
  return m.FSM_HALT(c1);

S246:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S254;
  return m.FSM_HALT(c1);

S248:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(10, c1);
  }
  return m.FSM_HALT(c1);

S250:
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S256;
  return m.FSM_HALT(c1);

S252:
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S258;
  return m.FSM_HALT(c1);

S254:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(12, c1);
  }
  return m.FSM_HALT(c1);

S256:
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S262;
  return m.FSM_HALT(c1);

S258:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S260:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S262:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S264;
  return m.FSM_HALT(c1);

S264:
  c1 = m.FSM_CHAR();
  if (m.FSM_META_EOB(c1)) {
    m.FSM_TAKE(12, c1);
  }
  return m.FSM_HALT(c1);
}

